

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Nengo frontend API &#8212; Nengo 3.0.0.dev0 docs</title>
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/mmenu.all.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/components.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/nengo.css" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<!--[if lte IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/placeholders/3.0.2/placeholders.min.js"></script><![endif]-->
<script type="text/javascript" src="https://cdn.crate.io/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/js/modernizr.js"></script>
    <script type="text/javascript" src="_static/js/underscore.min.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/searchtools.js"></script>
    <script type="text/javascript" src="_static/js/webflow.js"></script>
    <script type="text/javascript" src="_static/js/bootstrap.js"></script>
    <script type="text/javascript" src="_static/js/mmenu.all.min.js"></script>
    <script type="text/javascript" src="_static/js/fontawesome.js"></script>
    <script type="text/javascript" src="_static/js/custom.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Setting parameters with Configs" href="config.html" />
    <link rel="prev" title="User guide" href="user_guide.html" />
<link rel="stylesheet" type="text/css" href="_static/custom.css">


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-41658423-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-41658423-2');
</script>

<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>
<header class="header-nav">
  <div class="container">
    <div class="navbar w-nav" data-animation="default" data-collapse="small" data-contain="1" data-duration="400">
      <a class="brand w-nav-brand" href="https://www.nengo.ai/">
        <img src="https://www.nengo.ai/design/_images/general-full-light.svg" width="120">
      </a>
      <nav class="w-nav-menu main-nav" role="navigation">
        <div class="dropdownBackground">
          <span class="arrow"></span>
        </div>
        <ul id="menu-top-navigation" class="menu">
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/overview.html">Overview</a>
            <ul class="sub-menu">
                <li class="menu-item"><a href="https://www.nengo.ai/quickstart.html">Quick Start</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/documentation.html">Documentation</a>
            <table class="sub-menu">
              <tr>
                <td class="menu-heading">Core</td>
                <td class="menu-heading">Backends</td>
                <td class="menu-heading">Add-ons</td>
              </tr>
              <tr>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo">Nengo</a></td>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo-fpga">Nengo FPGA</a></td>
                <td class="menu-item"><a href="https://github.com/nengo/nengo-examples">Nengo Examples</a></td>
              </tr>
              <tr>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo-dl/">Nengo DL</a></td>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo-loihi">Nengo Loihi</a></td>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo-extras/">Nengo Extras</a></td>
              </tr>
              <tr>
                <td class="menu-item"><a href="https://github.com/nengo/nengo-gui">Nengo GUI</a></td>
                <td class="menu-item"><a href="https://github.com/nengo/nengo-mpi">Nengo MPI</a></td>
                <td class="menu-item"><a href="https://arvoelke.github.io/nengolib-docs/">Nengo Lib</a></td>
              </tr>
              <tr>
                <td class="menu-item"><a href="https://www.nengo.ai/nengo-spa/">Nengo SPA</a></td>
                <td class="menu-item"><a href="https://github.com/nengo/nengo-ocl">Nengo OpenCL</a></td>
                <td class="menu-item"></td>
              </tr>
              <tr>
                <td class="menu-item"></td>
                <td class="menu-item"><a href="https://github.com/project-rig/nengo_spinnaker">Nengo SpiNNaker</a></td>
                <td class="menu-item"></td>
              </tr>
            </table>
          </li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/community.html">Community</a>
            <ul class="sub-menu">
              <li class="menu-item"><a href="https://forum.nengo.ai/">Forum</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/publications.html">Publications</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/summerschool.html">Summer School</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/videos.html">Videos</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/people.html">People</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/projects.html">Development</a>
            <ul class="sub-menu">
              <li class="menu-item"><a href="https://www.nengo.ai/contributing.html">Contributor Guide</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/projects.html">Ecosystem</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item"><a href="https://www.nengo.ai/README.html">About</a></li>
          <li class="btn-link w-nav-link menu-item"><a href="https://www.nengo.ai/download.html">Download</a></li>
        </ul>
      </nav>

      <div id="mobile-nav" class="mm-menu">
        <ul class="offcanvas-menu">
          <li class="navlink w-nav-link menu-item"><a href="https://www.nengo.ai/overview.html">Overview</a></li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/documentation.html">Documentation</a>
            <ul class="sub-menu">
              <li class="menu-item"><a href="https://www.nengo.ai/quickstart.html">Quick Start</a></li>
              <li class="menu-item"><a href="http://www.nengo.ai/nengo">NengoCore</a></li>
              <li class="menu-item"><a href="https://github.com/nengo/nengo-gui#nengo-gui">NengoGUI</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/community.html">Community</a>
            <ul class="sub-menu">
              <li class="menu-item"><a href="https://forum.nengo.ai/">Forum</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/summerschool.html">Summer School</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/people.html">People</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item menu-item-has-children">
            <a href="https://www.nengo.ai/projects.html">Development</a>
            <ul class="sub-menu">
              <li class="menu-item"><a href="https://www.nengo.ai/contributing.html">Contributor Guide</a></li>
              <li class="menu-item"><a href="https://www.nengo.ai/projects.html">Ecosystem</a></li>
            </ul>
          </li>
          <li class="navlink w-nav-link menu-item"><a href="https://www.nengo.ai/README.html">About</a></li>
          <li class="btn-link w-nav-link menu-item"><a href="https://www.nengo.ai/download.html">Download</a></li>
        </ul>
      </div>

      <a href="#mobile-nav" class="fa fa-bars mobile-nav-button"></a>
    </div>
  </div>
</header>

<div class="w-section section border-top">
  <div class="container">
    <div class="row" id="frontend_api">
      <div class="col-md-4 col-lg-3">
        <aside class="wrapper-navleft"><div role="complementary" class="bs-docs-sidebar hidden-print" id="nav-affix">
  <ul class="bs-docs-sidenav bs-sidenav nav" role="complementary">
    <a href="index.html">
      <img class="logo" src="https://www.nengo.ai/design/_images/general-full-light.svg" alt="Nengo" width="200" />
    </a>
    <ul class="toctree nav nav-list">
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="user_guide.html">User guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nengo frontend API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nengo-objects">Nengo Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributions">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transforms">Transforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#neuron-types">Neuron types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#learning-rule-types">Learning rule types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processes">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synapse-models">Synapse models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decoder-and-connection-weight-solvers">Decoder and connection weight solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Setting parameters with Configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Reusable networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="spa.html">Semantic Pointer Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html">Advanced topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="backend_api.html">Nengo backend API</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html">Release History</a></li>
<li class="toctree-l2"><a class="reference internal" href="history.html">Nengo history</a></li>
<li class="toctree-l2"><a class="reference internal" href="converting.html">Converting from Nengo 1.4 to Nengo 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.nengo.ai/projects.html">Nengo ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Nengo license</a></li>
</ul>

    </ul>
  </ul>
<form id="form-search" class="form-search" action="search.html" method="get">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search" />
  </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form></div>
          
        </aside>
      </div>
      <div class="col-md-8 col-lg-9">
        <div class="body wrapper-content-right">
          
<div class="version-select-container">
    <div data-delay="0" class="w-dropdown">
        <div class="w-dropdown-toggle toggle">
            <div class="toggle-text">latest</div>
            <div class="w-icon-dropdown-toggle toggle-icon"></div>
        </div>
        <nav class="w-dropdown-list dropdown-list">
            
            
                <div class="w-dropdown-link">latest</div>
            

            
                
                    <a href="v2.8.0/frontend_api.html" class="w-dropdown-link">v2.8.0</a>
                
            
                
                    <a href="/frontend_api.html" class="w-dropdown-link"></a>
                
            
        </nav>
    </div>
</div>

          
  <div class="section" id="nengo-frontend-api">
<h1>Nengo frontend API<a class="headerlink" href="#nengo-frontend-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="nengo-objects">
<h2>Nengo Objects<a class="headerlink" href="#nengo-objects" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Network</span></code></a></p></td>
<td><p>A network contains ensembles, nodes, connections, and other networks.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Ensemble</span></code></a></p></td>
<td><p>A group of neurons that collectively represent a vector.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.ensemble.Neurons</span></code></a></p></td>
<td><p>An interface for making connections directly to an ensemble’s neurons.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Node</span></code></a></p></td>
<td><p>Provide non-neural inputs to Nengo objects and process outputs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Connection</span></code></a></p></td>
<td><p>Connects two objects together.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.connection.LearningRule" title="nengo.connection.LearningRule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.connection.LearningRule</span></code></a></p></td>
<td><p>An interface for making connections to a learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Probe</span></code></a></p></td>
<td><p>A probe is an object that collects data from the simulation.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Network">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Network</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">label=None</em>, <em class="sig-param">seed=None</em>, <em class="sig-param">add_to_container=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A network contains ensembles, nodes, connections, and other networks.</p>
<p>A network is primarily used for grouping together related
objects and connections for visualization purposes.
However, you can also use networks as a nice way to reuse
network creation code.</p>
<p>To group together related objects that you do not need to reuse,
you can create a new <code class="docutils literal notranslate"><span class="pre">Network</span></code> and add objects in a <code class="docutils literal notranslate"><span class="pre">with</span></code> block.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Vision&quot;</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Motor&quot;</span><span class="p">):</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
</pre></div>
</div>
<p>To reuse a group of related objects, you can create a new subclass
of <code class="docutils literal notranslate"><span class="pre">Network</span></code>, and add objects in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OcularDominance</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="n">left_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">right_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">left_eye</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">right_eye</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the network.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed that will be fed to the random number generator.
Setting the seed makes the network’s build process deterministic.</p>
</dd>
<dt><strong>add_to_container</strong><span class="classifier">bool, optional</span></dt><dd><p>Determines if this network will be added to the current container.
If None, this network will be added to the network at the top of the
<code class="docutils literal notranslate"><span class="pre">Network.context</span></code> stack unless the stack is empty.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>connections</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> instances in this network.</p>
</dd>
<dt><strong>ensembles</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ensemble</span></code></a> instances in this network.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>Name of this network.</p>
</dd>
<dt><strong>networks</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Network</span></code></a> instances in this network.</p>
</dd>
<dt><strong>nodes</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Node</span></code></a> instances in this network.</p>
</dd>
<dt><strong>probes</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Probe</span></code></a> instances in this network.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>Random seed used by this network.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Network.add">
<em class="property">static </em><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the passed object to <code class="docutils literal notranslate"><span class="pre">Network.context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.default_config">
<em class="property">static </em><code class="sig-name descname">default_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.default_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.default_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Config</span></code></a> object for setting defaults.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_objects">
<em class="property">property </em><code class="sig-name descname">all_objects</code><a class="headerlink" href="#nengo.Network.all_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All objects in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_ensembles">
<em class="property">property </em><code class="sig-name descname">all_ensembles</code><a class="headerlink" href="#nengo.Network.all_ensembles" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All ensembles in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_nodes">
<em class="property">property </em><code class="sig-name descname">all_nodes</code><a class="headerlink" href="#nengo.Network.all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All nodes in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_networks">
<em class="property">property </em><code class="sig-name descname">all_networks</code><a class="headerlink" href="#nengo.Network.all_networks" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All networks in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_connections">
<em class="property">property </em><code class="sig-name descname">all_connections</code><a class="headerlink" href="#nengo.Network.all_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All connections in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.all_probes">
<em class="property">property </em><code class="sig-name descname">all_probes</code><a class="headerlink" href="#nengo.Network.all_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All probes in this network and its subnetworks.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.config">
<em class="property">property </em><code class="sig-name descname">config</code><a class="headerlink" href="#nengo.Network.config" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Config</span></code></a>) Configuration for this network.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Network.n_neurons">
<em class="property">property </em><code class="sig-name descname">n_neurons</code><a class="headerlink" href="#nengo.Network.n_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Number of neurons in this network, including subnetworks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Ensemble">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Ensemble</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_neurons</em>, <em class="sig-param">dimensions</em>, <em class="sig-param">radius=Default&lt;1.0&gt;</em>, <em class="sig-param">encoders=Default&lt;UniformHypersphere(surface=True)&gt;</em>, <em class="sig-param">intercepts=Default&lt;Uniform(low=-1.0</em>, <em class="sig-param">high=1.0)&gt;</em>, <em class="sig-param">max_rates=Default&lt;Uniform(low=200</em>, <em class="sig-param">high=400)&gt;</em>, <em class="sig-param">eval_points=Default&lt;UniformHypersphere()&gt;</em>, <em class="sig-param">n_eval_points=Default&lt;None&gt;</em>, <em class="sig-param">neuron_type=Default&lt;LIF()&gt;</em>, <em class="sig-param">gain=Default&lt;None&gt;</em>, <em class="sig-param">bias=Default&lt;None&gt;</em>, <em class="sig-param">noise=Default&lt;None&gt;</em>, <em class="sig-param">normalize_encoders=Default&lt;True&gt;</em>, <em class="sig-param">label=Default&lt;None&gt;</em>, <em class="sig-param">seed=Default&lt;None&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Ensemble"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>A group of neurons that collectively represent a vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_neurons</strong><span class="classifier">int</span></dt><dd><p>The number of neurons.</p>
</dd>
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of representational dimensions.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>The representational radius of the ensemble.</p>
</dd>
<dt><strong>encoders</strong><span class="classifier">Distribution or (n_neurons, dimensions) array_like, optional</span></dt><dd><p>The encoders used to transform from representational space
to neuron space. Each row is a neuron’s encoder; each column is a
representational dimension.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">Distribution or (n_neurons,) array_like, optional</span></dt><dd><p>The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal notranslate"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>max_rates</strong><span class="classifier">Distribution or (n_neurons,) array_like, optional</span></dt><dd><p>The activity of each neuron when the input signal <code class="docutils literal notranslate"><span class="pre">x</span></code> is magnitude 1
and aligned with that neuron’s encoder <code class="docutils literal notranslate"><span class="pre">e</span></code>;
i.e., when <code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">Distribution or (n_eval_points, dims) array_like, optional</span></dt><dd><p>The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>n_eval_points</strong><span class="classifier">int, optional</span></dt><dd><p>The number of evaluation points to be drawn from the <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>neuron_type</strong><span class="classifier"><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeuronType</span></code></a>, optional</span></dt><dd><p>The model that simulates all neurons in the ensemble
(see <a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeuronType</span></code></a>).</p>
</dd>
<dt><strong>gain</strong><span class="classifier">Distribution or (n_neurons,) array_like</span></dt><dd><p>The gains associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal notranslate"><span class="pre">max_rates</span></code> and <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">Distribution or (n_neurons,) array_like</span></dt><dd><p>The biases associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal notranslate"><span class="pre">max_rates</span></code> and <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">Process, optional</span></dt><dd><p>Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>normalize_encoders</strong><span class="classifier">bool, optional</span></dt><dd><p>Indicates whether the encoders should be normalized.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bias</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The biases associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of representational dimensions.</p>
</dd>
<dt><strong>encoders</strong><span class="classifier">Distribution or (n_neurons, dimensions) array_like</span></dt><dd><p>The encoders, used to transform from representational space
to neuron space. Each row is a neuron’s encoder, each column is a
representational dimension.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">Distribution or (n_eval_points, dims) array_like</span></dt><dd><p>The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The gains associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">Distribution or (n_neurons) array_like or None</span></dt><dd><p>The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal notranslate"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str or None</span></dt><dd><p>A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>max_rates</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The activity of each neuron when <code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder.</p>
</dd>
<dt><strong>n_eval_points</strong><span class="classifier">int or None</span></dt><dd><p>The number of evaluation points to be drawn from the <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>n_neurons</strong><span class="classifier">int or None</span></dt><dd><p>The number of neurons.</p>
</dd>
<dt><strong>neuron_type</strong><span class="classifier">NeuronType</span></dt><dd><p>The model that simulates all neurons in the ensemble
(see <code class="docutils literal notranslate"><span class="pre">nengo.neurons</span></code>).</p>
</dd>
<dt><strong>noise</strong><span class="classifier">Process or None</span></dt><dd><p>Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The representational radius of the ensemble.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int or None</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Ensemble.neurons">
<em class="property">property </em><code class="sig-name descname">neurons</code><a class="headerlink" href="#nengo.Ensemble.neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>A direct interface to the neurons in the ensemble.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Ensemble.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Ensemble.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Ensemble.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Ensemble.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.ensemble.Neurons">
<em class="property">class </em><code class="sig-prename descclassname">nengo.ensemble.</code><code class="sig-name descname">Neurons</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ensemble</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.ensemble.Neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections directly to an ensemble’s neurons.</p>
<p>This should only ever be accessed through the <code class="docutils literal notranslate"><span class="pre">neurons</span></code> attribute of an
ensemble, as a way to signal to <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> that the connection
should be made directly to the neurons rather than to the ensemble’s
decoded value, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="nengo.ensemble.Neurons.ensemble">
<em class="property">property </em><code class="sig-name descname">ensemble</code><a class="headerlink" href="#nengo.ensemble.Neurons.ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>(Ensemble) The ensemble these neurons are part of.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.ensemble.Neurons.probeable">
<em class="property">property </em><code class="sig-name descname">probeable</code><a class="headerlink" href="#nengo.ensemble.Neurons.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the neuron population.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.ensemble.Neurons.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.ensemble.Neurons.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Node">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Node</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">output=Default&lt;None&gt;</em>, <em class="sig-param">size_in=Default&lt;None&gt;</em>, <em class="sig-param">size_out=Default&lt;None&gt;</em>, <em class="sig-param">label=Default&lt;None&gt;</em>, <em class="sig-param">seed=Default&lt;None&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/node.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide non-neural inputs to Nengo objects and process outputs.</p>
<p>Nodes can accept input, and perform arbitrary computations
for the purpose of controlling a Nengo simulation.
Nodes are typically not part of a brain model per se,
but serve to summarize the assumptions being made
about sensory data or other environment variables
that cannot be generated by a brain model alone.</p>
<p>Nodes can also be used to test models by providing specific input signals
to parts of the model, and can simplify the input/output interface of a
<a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Network</span></code></a> when used as a relay to/from its internal
ensembles (see <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EnsembleArray</span></code></a> for an example).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output</strong><span class="classifier">callable, array_like, or None</span></dt><dd><p>Function that transforms the Node inputs into outputs,
a constant output value, or None to transmit signals unchanged.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the input data parameter.</p>
</dd>
<dt><strong>size_out</strong><span class="classifier">int, optional</span></dt><dd><p>The size of the output signal. If None, it will be determined
based on the values of <code class="docutils literal notranslate"><span class="pre">output</span></code> and <code class="docutils literal notranslate"><span class="pre">size_in</span></code>.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the node. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.
Note: no aspects of the node are random, so currently setting
this seed has no effect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>The name of the node.</p>
</dd>
<dt><strong>output</strong><span class="classifier">callable, array_like, or None</span></dt><dd><p>The given output.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int</span></dt><dd><p>The number of dimensions for incoming connection.</p>
</dd>
<dt><strong>size_out</strong><span class="classifier">int</span></dt><dd><p>The number of output dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.Connection">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Connection</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">pre</em>, <em class="sig-param">post</em>, <em class="sig-param">synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">function=Default&lt;None&gt;</em>, <em class="sig-param">transform=Default&lt;1.0&gt;</em>, <em class="sig-param">solver=Default&lt;LstsqL2()&gt;</em>, <em class="sig-param">learning_rule_type=Default&lt;None&gt;</em>, <em class="sig-param">eval_points=Default&lt;None&gt;</em>, <em class="sig-param">scale_eval_points=Default&lt;True&gt;</em>, <em class="sig-param">label=Default&lt;None&gt;</em>, <em class="sig-param">seed=Default&lt;None&gt;</em>, <em class="sig-param">modulatory=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects two objects together.</p>
<p>The connection between the two object is unidirectional,
transmitting information from the first argument, <code class="docutils literal notranslate"><span class="pre">pre</span></code>,
to the second argument, <code class="docutils literal notranslate"><span class="pre">post</span></code>.</p>
<p>Almost any Nengo object can act as the pre or post side of a connection.
Additionally, you can use Python slice syntax to access only some of the
dimensions of the pre or post object.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">node</span></code> has <code class="docutils literal notranslate"><span class="pre">size_out=2</span></code> and <code class="docutils literal notranslate"><span class="pre">ensemble</span></code> has
<code class="docutils literal notranslate"><span class="pre">size_in=1</span></code>, we could not create the following connection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<p>But, we could create either of these two connections:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
<span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>pre</strong><span class="classifier">Ensemble or Neurons or Node</span></dt><dd><p>The source Nengo object for the connection.</p>
</dd>
<dt><strong>post</strong><span class="classifier">Ensemble or Neurons or Node or Probe</span></dt><dd><p>The destination object for the connection.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse or None, optional</span></dt><dd><p>Synapse model to use for filtering (see <a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>).
If <em>None</em>, no synapse will be used and information will be transmitted
without any delay (if supported by the backend—some backends may
introduce a single time step delay).</p>
<p>Note that at least one connection must have a synapse that is not
<em>None</em> if components are connected in a cycle. Furthermore, a synaptic
filter with a zero time constant is different from a <em>None</em> synapse
as a synaptic filter will always add a delay of at least one time step.</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable or (n_eval_points, size_mid) array_like, optional</span></dt><dd><p>Function to compute across the connection. Note that <code class="docutils literal notranslate"><span class="pre">pre</span></code> must be
an ensemble to apply a function across the connection.
If an array is passed, the function is implicitly defined by the
points in the array and the provided <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>, which have a
one-to-one correspondence.</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(size_out, size_mid) array_like, optional</span></dt><dd><p>Linear transform mapping the pre output to the post input.
This transform is in terms of the sliced size; if either pre
or post is a slice, the transform must be shaped according to
the sliced dimensionality. Additionally, the function is applied
before the transform, so if a function is computed across the
connection, the transform must be of shape <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_mid)</span></code>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver, optional</span></dt><dd><p>Solver instance to compute decoders or weights
(see <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a>). If <code class="docutils literal notranslate"><span class="pre">solver.weights</span></code> is True, a full
connection weight matrix is computed instead of decoders.</p>
</dd>
<dt><strong>learning_rule_type</strong><span class="classifier">LearningRuleType or iterable of LearningRuleType,                          optional</span></dt><dd><p>Modifies the decoders or connection weights during simulation.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">(n_eval_points, size_in) array_like or int, optional</span></dt><dd><p>Points at which to evaluate <code class="docutils literal notranslate"><span class="pre">function</span></code> when computing decoders,
spanning the interval (-pre.radius, pre.radius) in each dimension.
If None, will use the eval_points associated with <code class="docutils literal notranslate"><span class="pre">pre</span></code>.</p>
</dd>
<dt><strong>scale_eval_points</strong><span class="classifier">bool, optional</span></dt><dd><p>Indicates whether the evaluation points should be scaled
by the radius of the pre Ensemble.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A descriptive label for the connection.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_decoded</strong><span class="classifier">bool</span></dt><dd><p>True if and only if the connection is decoded. This will not occur
when <code class="docutils literal notranslate"><span class="pre">solver.weights</span></code> is True or both pre and post are
<a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neurons</span></code></a>.</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p>The given function.</p>
</dd>
<dt><strong>function_size</strong><span class="classifier">int</span></dt><dd><p>The output dimensionality of the given function. If no function is
specified, function_size will be 0.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>A human-readable connection label for debugging and visualization.
If not overridden, incorporates the labels of the pre and post objects.</p>
</dd>
<dt><strong>learning_rule_type</strong><span class="classifier">instance or list or dict of LearningRuleType, optional</span></dt><dd><p>The learning rule types.</p>
</dd>
<dt><strong>post</strong><span class="classifier">Ensemble or Neurons or Node or Probe or ObjView</span></dt><dd><p>The given post object.</p>
</dd>
<dt><strong>post_obj</strong><span class="classifier">Ensemble or Neurons or Node or Probe</span></dt><dd><p>The underlying post object, even if <code class="docutils literal notranslate"><span class="pre">post</span></code> is an <code class="docutils literal notranslate"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>post_slice</strong><span class="classifier">slice or list or None</span></dt><dd><p>The slice associated with <code class="docutils literal notranslate"><span class="pre">post</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>pre</strong><span class="classifier">Ensemble or Neurons or Node or ObjView</span></dt><dd><p>The given pre object.</p>
</dd>
<dt><strong>pre_obj</strong><span class="classifier">Ensemble or Neurons or Node</span></dt><dd><p>The underlying pre object, even if <code class="docutils literal notranslate"><span class="pre">post</span></code> is an <code class="docutils literal notranslate"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>pre_slice</strong><span class="classifier">slice or list or None</span></dt><dd><p>The slice associated with <code class="docutils literal notranslate"><span class="pre">pre</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver</span></dt><dd><p>The Solver instance that will be used to compute decoders or weights
(see <code class="docutils literal notranslate"><span class="pre">nengo.solvers</span></code>).</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse</span></dt><dd><p>The Synapse model used for filtering across the connection
(see <code class="docutils literal notranslate"><span class="pre">nengo.synapses</span></code>).</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(size_out, size_mid) array_like</span></dt><dd><p>Linear transform mapping the pre function output to the post input.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Connection.learning_rule">
<em class="property">property </em><code class="sig-name descname">learning_rule</code><a class="headerlink" href="#nengo.Connection.learning_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>(LearningRule or iterable) Connectable learning rule object(s).</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Connection.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Connection.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the pre object.</p>
<p>Also the input size of the function, if one is specified.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Connection.size_mid">
<em class="property">property </em><code class="sig-name descname">size_mid</code><a class="headerlink" href="#nengo.Connection.size_mid" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the function, if specified.</p>
<p>If the function is not specified, then <code class="docutils literal notranslate"><span class="pre">size_in</span> <span class="pre">==</span> <span class="pre">size_mid</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Connection.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Connection.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of input dimensions of the post object.</p>
<p>Also the number of output dimensions of the transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.connection.LearningRule">
<em class="property">class </em><code class="sig-prename descclassname">nengo.connection.</code><code class="sig-name descname">LearningRule</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">connection</em>, <em class="sig-param">learning_rule_type</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#LearningRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.connection.LearningRule" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections to a learning rule.</p>
<p>Connections to a learning rule are to allow elements of the network to
affect the learning rule. For example, learning rules that use error
information can obtain that information through a connection.</p>
<p>Learning rule objects should only ever be accessed through the
<code class="docutils literal notranslate"><span class="pre">learning_rule</span></code> attribute of a connection.</p>
<dl class="method">
<dt id="nengo.connection.LearningRule.connection">
<em class="property">property </em><code class="sig-name descname">connection</code><a class="headerlink" href="#nengo.connection.LearningRule.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>(Connection) The connection modified by the learning rule.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.connection.LearningRule.modifies">
<em class="property">property </em><code class="sig-name descname">modifies</code><a class="headerlink" href="#nengo.connection.LearningRule.modifies" title="Permalink to this definition">¶</a></dt>
<dd><p>(str) The variable modified by the learning rule.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.connection.LearningRule.probeable">
<em class="property">property </em><code class="sig-name descname">probeable</code><a class="headerlink" href="#nengo.connection.LearningRule.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the learning rule.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.connection.LearningRule.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.connection.LearningRule.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from learning rules, so always 0.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Probe">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Probe</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">target</em>, <em class="sig-param">attr=None</em>, <em class="sig-param">sample_every=Default&lt;None&gt;</em>, <em class="sig-param">synapse=Default&lt;None&gt;</em>, <em class="sig-param">solver=Default&lt;ConnectionDefault&gt;</em>, <em class="sig-param">label=Default&lt;None&gt;</em>, <em class="sig-param">seed=Default&lt;None&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/probe.html#Probe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Probe" title="Permalink to this definition">¶</a></dt>
<dd><p>A probe is an object that collects data from the simulation.</p>
<p>This is to be used in any situation where you wish to gather simulation
data (spike data, represented values, neuron voltages, etc.) for analysis.</p>
<p>Probes do not directly affect the simulation.</p>
<p>All Nengo objects can be probed (except Probes themselves).
Each object has different attributes that can be probed.
To see what is probeable for each object, print its
<code class="docutils literal notranslate"><span class="pre">probeable</span></code> attribute.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">ens</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ens</span><span class="o">.</span><span class="n">probeable</span><span class="p">)</span>
<span class="go">[&#39;decoded_output&#39;, &#39;input&#39;]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target</strong><span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt><dd><p>The object to probe.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">str, optional</span></dt><dd><p>The signal to probe. Refer to the target’s <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list for
details. If None, the first element in the <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list
will be used.</p>
</dd>
<dt><strong>sample_every</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling period in seconds. If None, the <code class="docutils literal notranslate"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse, optional</span></dt><dd><p>A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver, optional</span></dt><dd><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> to compute decoders
for probes that require them.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the probe. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>attr</strong><span class="classifier">str or None</span></dt><dd><p>The signal that will be probed. If None, the first element of the
target’s <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list will be used.</p>
</dd>
<dt><strong>sample_every</strong><span class="classifier">float or None</span></dt><dd><p>Sampling period in seconds. If None, the <code class="docutils literal notranslate"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver or None</span></dt><dd><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> to compute decoders. Only used for probes
of an ensemble’s decoded output.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse or None</span></dt><dd><p>A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt><dd><p>The object to probe.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Probe.obj">
<em class="property">property </em><code class="sig-name descname">obj</code><a class="headerlink" href="#nengo.Probe.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>(Nengo object) The underlying Nengo object target.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Probe.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Probe.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Dimensionality of the probed signal.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Probe.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Probe.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from probes, so always 0.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Probe.slice">
<em class="property">property </em><code class="sig-name descname">slice</code><a class="headerlink" href="#nengo.Probe.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>(slice) The slice associated with the Nengo object target.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Distribution</span></code></a></p></td>
<td><p>A base class for probability distributions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.get_samples" title="nengo.dists.get_samples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.get_samples</span></code></a></p></td>
<td><p>Convenience function to sample a distribution or return samples.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Uniform" title="nengo.dists.Uniform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Uniform</span></code></a></p></td>
<td><p>A uniform distribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.Gaussian" title="nengo.dists.Gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Gaussian</span></code></a></p></td>
<td><p>A Gaussian distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Exponential" title="nengo.dists.Exponential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Exponential</span></code></a></p></td>
<td><p>An exponential distribution (optionally with high values clipped).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.UniformHypersphere" title="nengo.dists.UniformHypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.UniformHypersphere</span></code></a></p></td>
<td><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Choice" title="nengo.dists.Choice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Choice</span></code></a></p></td>
<td><p>Discrete distribution across a set of possible values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.Samples" title="nengo.dists.Samples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Samples</span></code></a></p></td>
<td><p>A set of samples.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.PDF" title="nengo.dists.PDF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.PDF</span></code></a></p></td>
<td><p>An arbitrary distribution from a PDF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p></td>
<td><p>Distribution of the square root of a Beta distributed random variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SubvectorLength</span></code></a></p></td>
<td><p>Distribution of the length of a subvectors of a unit vector.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.CosineSimilarity" title="nengo.dists.CosineSimilarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.CosineSimilarity</span></code></a></p></td>
<td><p>Distribution of the cosine of the angle between two random vectors.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.dists.Distribution">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Distribution</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for probability distributions.</p>
<p>The only thing that a probabilities distribution need to define is a
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a> method. This base class ensures that all
distributions accept the same arguments for the sample function.</p>
<dl class="method">
<dt id="nengo.dists.Distribution.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Distribution.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.dists.get_samples">
<code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">get_samples</code><span class="sig-paren">(</span><em class="sig-param">dist_or_samples</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#get_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.get_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to sample a distribution or return samples.</p>
<p>Use this function in situations where you accept an argument that could
be a distribution, or could be an <code class="docutils literal notranslate"><span class="pre">array_like</span></code> of samples.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dist_or_samples</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or (n, d) array_like</span></dt><dd><p>Source of the samples to be returned.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState, optional</span></dt><dd><p>Random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n, d) array_like</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">samples</span> <span class="o">=</span> <span class="n">get_samples</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">0.057277898442269548</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Uniform">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Uniform</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">low</em>, <em class="sig-param">high</em>, <em class="sig-param">integer=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>A uniform distribution.</p>
<p>It’s equally likely to get any scalar between <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code>.</p>
<p>Note that the order of <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> doesn’t matter;
if <code class="docutils literal notranslate"><span class="pre">low</span> <span class="pre">&lt;</span> <span class="pre">high</span></code> this will still work, and <code class="docutils literal notranslate"><span class="pre">low</span></code> will still
be a closed interval while <code class="docutils literal notranslate"><span class="pre">high</span></code> is open.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>low</strong><span class="classifier">Number</span></dt><dd><p>The closed lower bound of the uniform distribution; samples &gt;= low</p>
</dd>
<dt><strong>high</strong><span class="classifier">Number</span></dt><dd><p>The open upper bound of the uniform distribution; samples &lt; high</p>
</dd>
<dt><strong>integer</strong><span class="classifier">boolean, optional</span></dt><dd><p>If true, sample from a uniform distribution of integers. In this case,
low and high should be integers.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.Uniform.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Uniform.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.Gaussian">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Gaussian</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">mean</em>, <em class="sig-param">std</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Gaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>A Gaussian distribution.</p>
<p>This represents a bell-curve centred at <code class="docutils literal notranslate"><span class="pre">mean</span></code> and with
spread represented by the standard deviation, <code class="docutils literal notranslate"><span class="pre">std</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">Number</span></dt><dd><p>The mean of the Gaussian.</p>
</dd>
<dt><strong>std</strong><span class="classifier">Number</span></dt><dd><p>The standard deviation of the Gaussian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValidationError if std is &lt;= 0</dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.Gaussian.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Gaussian.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.Exponential">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Exponential</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">scale</em>, <em class="sig-param">shift=0.0</em>, <em class="sig-param">high=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Exponential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>An exponential distribution (optionally with high values clipped).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">high</span></code> is left to its default value of infinity, this is a standard
exponential distribution. If <code class="docutils literal notranslate"><span class="pre">high</span></code> is set, then any sampled values at
or above <code class="docutils literal notranslate"><span class="pre">high</span></code> will be clipped so they are slightly below <code class="docutils literal notranslate"><span class="pre">high</span></code>.
This is useful for thresholding and, by extension,
<a class="reference internal" href="networks.html#nengo.networks.AssociativeMemory" title="nengo.networks.AssociativeMemory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">networks.AssociativeMemory</span></code></a>.</p>
<p>The probability distribution function (PDF) is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">shift</span>
<span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="n">scale</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">shift</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">high</span>
       <span class="o">|</span>  <span class="n">n</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">high</span> <span class="o">-</span> <span class="n">eps</span>
       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">high</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is such that the PDF integrates to one, and <code class="docutils literal notranslate"><span class="pre">eps</span></code> is an
infintesimally small number such that samples of <code class="docutils literal notranslate"><span class="pre">x</span></code> are strictly less
than <code class="docutils literal notranslate"><span class="pre">high</span></code> (in practice, <code class="docutils literal notranslate"><span class="pre">eps</span></code> depends on floating point precision).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float</span></dt><dd><p>The scale parameter (inverse of the rate parameter lambda). Larger
values make the distribution narrower (sharper peak).</p>
</dd>
<dt><strong>shift</strong><span class="classifier">float, optional</span></dt><dd><p>Amount to shift the distribution by. There will be no values smaller
than this shift when sampling from the distribution.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float, optional</span></dt><dd><p>All values larger than or equal to this value will be clipped to
slightly less than this value.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.Exponential.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Exponential.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.UniformHypersphere">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">UniformHypersphere</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">surface=False</em>, <em class="sig-param">min_magnitude=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#UniformHypersphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p>
<p>Sample points are uniformly distributed across the volume (default) or
surface of an n-dimensional unit hypersphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>surface</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether sample points should be distributed uniformly
over the surface of the hyperphere (True),
or within the hypersphere (False).</p>
</dd>
<dt><strong>min_magnitude</strong><span class="classifier">Number, optional</span></dt><dd><p>Lower bound on the returned vector magnitudes (such that they are in
the range <code class="docutils literal notranslate"><span class="pre">[min_magnitude,</span> <span class="pre">1]</span></code>). Must be in the range [0, 1).
Ignored if <code class="docutils literal notranslate"><span class="pre">surface</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.UniformHypersphere.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#UniformHypersphere.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.Choice">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Choice</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">options</em>, <em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Choice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete distribution across a set of possible values.</p>
<p>The same as <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.choice</span></code></a>, except can take vector or matrix values
for the choices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>options</strong><span class="classifier">(N, …) array_like</span></dt><dd><p>The options (choices) to choose between. The choice is always done
along the first axis, so if <code class="docutils literal notranslate"><span class="pre">options</span></code> is a matrix, the options are
the rows of that matrix.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Weights controlling the probability of selecting each option. Will
automatically be normalized. If None, weights be uniformly distributed.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.Choice.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Choice.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.Samples">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Samples</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of samples.</p>
<p>This class is a subclass of <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> so that it can be used in any
situation that calls for a  <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a>. However, the call to
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a> must match the dimensions of the samples or
a <a class="reference internal" href="config.html#nengo.exceptions.ValidationError" title="nengo.exceptions.ValidationError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ValidationError</span></code></a> will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n, d) array_like</span></dt><dd><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> must match what is eventually passed to</dt><dd><p><a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.Samples.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Samples.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.PDF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">PDF</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#PDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF" title="Permalink to this definition">¶</a></dt>
<dd><p>An arbitrary distribution from a PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">vector_like (n,)</span></dt><dd><p>Values of the points to sample from (interpolated).</p>
</dd>
<dt><strong>p</strong><span class="classifier">vector_like (n,)</span></dt><dd><p>Probabilities of the <code class="docutils literal notranslate"><span class="pre">x</span></code> points.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.dists.PDF.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#PDF.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.SqrtBeta">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">SqrtBeta</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">m=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the square root of a Beta distributed random variable.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></code> dimensional random unit vectors, the length of subvectors
with <code class="docutils literal notranslate"><span class="pre">m</span></code> elements will be distributed according to this distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>Number of subvectors.</p>
</dd>
<dt><strong>m: int, optional</strong></dt><dd><p>Length of each subvector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SubvectorLength</span></code></a></dt><dd></dd>
</dl>
</div>
<dl class="method">
<dt id="nengo.dists.SqrtBeta.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">num</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.cdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability that <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.pdf">
<code class="sig-name descname">pdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability density at <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.ppf">
<code class="sig-name descname">ppf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.ppf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Cumulative probabilities in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ppf</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal notranslate"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.SubvectorLength">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">SubvectorLength</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dimensions</em>, <em class="sig-param">subdimensions=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SubvectorLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SubvectorLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the length of a subvectors of a unit vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>Dimensionality of the complete unit vector.</p>
</dd>
<dt><strong>subdimensions</strong><span class="classifier">int, optional</span></dt><dd><p>Dimensionality of the subvector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.CosineSimilarity">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">CosineSimilarity</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dimensions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the cosine of the angle between two random vectors.</p>
<p>The “cosine similarity” is the cosine of the angle between two vectors,
which is equal to the dot product of the vectors, divided by the L2-norms
of the individual vectors. When these vectors are unit length, this is then
simply the distribution of their dot product.</p>
<p>This is also equivalent to the distribution of a single coefficient from a
unit vector (a single dimension of <code class="docutils literal notranslate"><span class="pre">UniformHypersphere(surface=True)</span></code>).
Furthermore, <code class="docutils literal notranslate"><span class="pre">CosineSimilarity(d+2)</span></code> is equivalent to the distribution of
a single coordinate from points uniformly sampled from the d-dimensional
unit ball (a single dimension of
<code class="docutils literal notranslate"><span class="pre">UniformHypersphere(surface=False).sample(n,</span> <span class="pre">d)</span></code>). These relationships
have been detailed in <a class="reference internal" href="#r0dd7d02f1d08-voelker2017" id="id1"><span>[R0dd7d02f1d08-Voelker2017]</span></a>.</p>
<p>This can be used to calculate an intercept <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> such that
<code class="docutils literal notranslate"><span class="pre">dot(u,</span> <span class="pre">v)</span> <span class="pre">&gt;=</span> <span class="pre">c</span></code> with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>, for random unit vectors <code class="docutils literal notranslate"><span class="pre">u</span></code>
and <code class="docutils literal notranslate"><span class="pre">v</span></code>. In other words, a neuron with intercept <code class="docutils literal notranslate"><span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> will
fire with probability <code class="docutils literal notranslate"><span class="pre">p</span></code> for a random unit length input.</p>
<dl class="citation">
<dt class="label" id="r0dd7d02f1d08-voelker2017"><span class="brackets"><a class="fn-backref" href="#id1">R0dd7d02f1d08-Voelker2017</a></span></dt>
<dd><p><a class="reference external" href="http://compneuro.uwaterloo.ca/publications/voelker2017.html">Aaron R. Voelker, Jan Gosmann, and Terrence C. Stewart.
Efficiently sampling vectors and coordinates from the n-sphere and
n-ball. Technical Report, Centre for Theoretical Neuroscience,
Waterloo, ON, 2017</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions: int</strong></dt><dd><p>Dimensionality of the complete unit vector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></dt><dd></dd>
</dl>
</div>
<dl class="method">
<dt id="nengo.dists.CosineSimilarity.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">num</em>, <em class="sig-param">d=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.CosineSimilarity.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity.cdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability that <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.CosineSimilarity.pdf">
<code class="sig-name descname">pdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity.pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability density at <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.CosineSimilarity.ppf">
<code class="sig-name descname">ppf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity.ppf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Cumulative probabilities in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ppf</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal notranslate"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="transforms">
<h2>Transforms<a class="headerlink" href="#transforms" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.Transform" title="nengo.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.Transform</span></code></a></p></td>
<td><p>A base class for connection transforms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.transforms.Dense" title="nengo.transforms.Dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.Dense</span></code></a></p></td>
<td><p>A dense matrix transformation between an input and output signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.Sparse" title="nengo.transforms.Sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.Sparse</span></code></a></p></td>
<td><p>A sparse matrix transformation between an input and output signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.transforms.Convolution" title="nengo.transforms.Convolution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.Convolution</span></code></a></p></td>
<td><p>An N-dimensional convolutional transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.ChannelShape" title="nengo.transforms.ChannelShape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.ChannelShape</span></code></a></p></td>
<td><p>Represents shape information with variable channel position.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.transforms.Transform">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">Transform</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for connection transforms.</p>
<dl class="method">
<dt id="nengo.transforms.Transform.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Transform.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Transform.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Transform.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Transform.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Transform.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Transform.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.transforms.Dense">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">Dense</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape</em>, <em class="sig-param">init=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Dense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Dense" title="Permalink to this definition">¶</a></dt>
<dd><p>A dense matrix transformation between an input and output signal.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The shape of the dense matrix: <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_in)</span></code>.</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or array_like, optional</span></dt><dd><p>A Distribution used to initialize the transform matrix, or a concrete
instantiation for the matrix. If the matrix is square we also allow a
scalar (equivalent to <code class="docutils literal notranslate"><span class="pre">np.eye(n)</span> <span class="pre">*</span> <span class="pre">init</span></code>) or a vector (equivalent to
<code class="docutils literal notranslate"><span class="pre">np.diag(init)</span></code>) to represent the matrix more compactly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.transforms.Dense.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Dense.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Dense.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Dense.init_shape">
<em class="property">property </em><code class="sig-name descname">init_shape</code><a class="headerlink" href="#nengo.transforms.Dense.init_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the initial value.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Dense.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Dense.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Dense.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Dense.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.transforms.Sparse">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">Sparse</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">init=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Sparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix transformation between an input and output signal.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The full shape of the sparse matrix: <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_in)</span></code>.</p>
</dd>
<dt><strong>inds</strong><span class="classifier">array_like of int</span></dt><dd><p>The indices of</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or array_like, optional (Default: 1.0)</span></dt><dd><p>A Distribution used to initialize the transform matrix, or a concrete
instantiation for the matrix. If the matrix is square we also allow a
scalar (equivalent to <code class="docutils literal notranslate"><span class="pre">np.eye(n)</span> <span class="pre">*</span> <span class="pre">init</span></code>) or a vector (equivalent to
<code class="docutils literal notranslate"><span class="pre">np.diag(init)</span></code>) to represent the matrix more compactly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.transforms.Sparse.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Sparse.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Sparse.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Sparse.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Sparse.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Sparse.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Sparse.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.transforms.Convolution">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">Convolution</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_filters</em>, <em class="sig-param">input_shape</em>, <em class="sig-param">kernel_size=(3</em>, <em class="sig-param">3)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding='valid'</em>, <em class="sig-param">channels_last=True</em>, <em class="sig-param">init=Uniform(low=-1</em>, <em class="sig-param">high=1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Convolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional convolutional transform.</p>
<p>The dimensionality of the convolution is determined by the input shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_filters</strong><span class="classifier">int</span></dt><dd><p>The number of convolutional filters to apply</p>
</dd>
<dt><strong>input_shape</strong><span class="classifier">tuple of int or <a class="reference internal" href="#nengo.transforms.ChannelShape" title="nengo.transforms.ChannelShape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ChannelShape</span></code></a></span></dt><dd><p>Shape of the input signal to the convolution; e.g.,
<code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">width,</span> <span class="pre">channels)</span></code> for a 2D convolution with
<code class="docutils literal notranslate"><span class="pre">channels_last=True</span></code>.</p>
</dd>
<dt><strong>kernel_size</strong><span class="classifier">tuple of int, optional</span></dt><dd><p>Size of the convolutional kernels (1 element for a 1D convolution,
2 for a 2D convolution, etc.).</p>
</dd>
<dt><strong>strides</strong><span class="classifier">tuple of int, optional</span></dt><dd><p>Stride of the convolution (1 element for a 1D convolution, 2 for
a 2D convolution, etc.).</p>
</dd>
<dt><strong>padding</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">&quot;same&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;valid&quot;</span></code>, optional</span></dt><dd><p>Padding method for input signal. “Valid” means no padding, and
convolution will only be applied to the fully-overlapping areas of the
input signal (meaning the output will be smaller). “Same” means that
the input signal is zero-padded so that the output is the same shape
as the input.</p>
</dd>
<dt><strong>channels_last</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the channels are the last dimension in the input
signal (e.g., a 28x28 image with 3 channels would have shape
<code class="docutils literal notranslate"><span class="pre">(28,</span> <span class="pre">28,</span> <span class="pre">3)</span></code>).  <code class="docutils literal notranslate"><span class="pre">False</span></code> means that channels are the first
dimension (e.g., <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">28,</span> <span class="pre">28)</span></code>).</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a>, optional</span></dt><dd><p>A predefined kernel with shape
<code class="docutils literal notranslate"><span class="pre">kernel_size</span> <span class="pre">+</span> <span class="pre">(input_channels,</span> <span class="pre">n_filters)</span></code>, or a <code class="docutils literal notranslate"><span class="pre">Distribution</span></code>
that will be used to initialize the kernel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As is typical in neural networks, this is technically correlation rather
than convolution (because the kernel is not flipped).</p>
<dl class="method">
<dt id="nengo.transforms.Convolution.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#Convolution.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Convolution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Convolution.kernel_shape">
<em class="property">property </em><code class="sig-name descname">kernel_shape</code><a class="headerlink" href="#nengo.transforms.Convolution.kernel_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Full shape of kernel.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Convolution.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Convolution.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Convolution.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Convolution.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Convolution.dimensions">
<em class="property">property </em><code class="sig-name descname">dimensions</code><a class="headerlink" href="#nengo.transforms.Convolution.dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimensionality of convolution.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.Convolution.output_shape">
<em class="property">property </em><code class="sig-name descname">output_shape</code><a class="headerlink" href="#nengo.transforms.Convolution.output_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Output shape after applying convolution to input.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.transforms.ChannelShape">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">ChannelShape</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape</em>, <em class="sig-param">channels_last=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/transforms.html#ChannelShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.ChannelShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents shape information with variable channel position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>Signal shape</p>
</dd>
<dt><strong>channels_last</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), the last item in <code class="docutils literal notranslate"><span class="pre">shape</span></code> represents the channels,
and the rest are spatial dimensions. Otherwise, the first item in
<code class="docutils literal notranslate"><span class="pre">shape</span></code> is the channel dimension.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.transforms.ChannelShape.spatial_shape">
<em class="property">property </em><code class="sig-name descname">spatial_shape</code><a class="headerlink" href="#nengo.transforms.ChannelShape.spatial_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The spatial part of the shape (omitting channels).</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.ChannelShape.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#nengo.transforms.ChannelShape.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of elements in the represented signal.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.ChannelShape.n_channels">
<em class="property">property </em><code class="sig-name descname">n_channels</code><a class="headerlink" href="#nengo.transforms.ChannelShape.n_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of channels in the represented signal.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.transforms.ChannelShape.dimensions">
<em class="property">property </em><code class="sig-name descname">dimensions</code><a class="headerlink" href="#nengo.transforms.ChannelShape.dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>The spatial dimensionality of the represented signal.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="neuron-types">
<h2>Neuron types<a class="headerlink" href="#neuron-types" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.neurons.NeuronType</span></code></a></p></td>
<td><p>Base class for Nengo neuron models.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Direct</span></code></a></p></td>
<td><p>Signifies that an ensemble should simulate in direct mode.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.RectifiedLinear" title="nengo.RectifiedLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.RectifiedLinear</span></code></a></p></td>
<td><p>A rectified linear neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.SpikingRectifiedLinear" title="nengo.SpikingRectifiedLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.SpikingRectifiedLinear</span></code></a></p></td>
<td><p>A rectified integrate and fire neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Sigmoid" title="nengo.Sigmoid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Sigmoid</span></code></a></p></td>
<td><p>A neuron model whose response curve is a sigmoid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.LIF" title="nengo.LIF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LIF</span></code></a></p></td>
<td><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.LIFRate" title="nengo.LIFRate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LIFRate</span></code></a></p></td>
<td><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.AdaptiveLIF" title="nengo.AdaptiveLIF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.AdaptiveLIF</span></code></a></p></td>
<td><p>Adaptive spiking version of the LIF neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.AdaptiveLIFRate" title="nengo.AdaptiveLIFRate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.AdaptiveLIFRate</span></code></a></p></td>
<td><p>Adaptive non-spiking version of the LIF neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Izhikevich" title="nengo.Izhikevich"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Izhikevich</span></code></a></p></td>
<td><p>Izhikevich neuron model.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.neurons.NeuronType">
<em class="property">class </em><code class="sig-prename descclassname">nengo.neurons.</code><code class="sig-name descname">NeuronType</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for Nengo neuron models.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>probeable</strong><span class="classifier">tuple</span></dt><dd><p>Signals that can be probed in the neuron population.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.neurons.NeuronType.current">
<code class="sig-name descname">current</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute current injected in each neuron given input, gain and bias.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> is assumed to be already projected onto the encoders
associated with the neurons and normalized to radius 1, so the maximum
expected current for a neuron occurs when input for that neuron is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n_samples,) or (n_samples, n_neurons) array_like</span></dt><dd><p>Scalar inputs for which to calculate current.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>current</strong><span class="classifier">(n_samples, n_neurons)</span></dt><dd><p>Current to be injected in each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rates</em>, <em class="sig-param">intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gain and bias needed to satisfy max_rates, intercepts.</p>
<p>This takes the neurons, approximates their response function, and then
uses that approximation to find the gain and bias value that will give
the requested intercepts and max_rates.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max_rates and intercepts given gain and bias.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given input <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This default implementation takes the naive approach of running the
step function for a second. This should suffice for most rate-based
neuron types; for spiking neurons it will likely fail (those models
should override this function).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> is assumed to be already projected onto the encoders
associated with the neurons and normalized to radius 1, so the maximum
expected rate for a neuron occurs when input for that neuron is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n_samples,) or (n_samples, n_neurons) array_like</span></dt><dd><p>Scalar inputs for which to calculate rates.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rates</strong><span class="classifier">(n_samples, n_neurons) ndarray</span></dt><dd><p>The firing rates at each given value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activities associated with each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Direct">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Direct</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Signifies that an ensemble should simulate in direct mode.</p>
<p>In direct mode, the ensemble represents and transforms signals perfectly,
rather than through a neural approximation. Note that direct mode ensembles
with recurrent connections can easily diverge; most other neuron types will
instead saturate at a certain high firing rate.</p>
<dl class="method">
<dt id="nengo.Direct.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rates</em>, <em class="sig-param">intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if called.</p>
<p>Rather than calling this function, the simulator will detect that
the ensemble is in direct mode, and bypass the neural approximation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.RectifiedLinear">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">RectifiedLinear</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified linear neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless it passes below zero, at which point
the neural activity will stay at zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.RectifiedLinear.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rates</em>, <em class="sig-param">intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine gain and bias by shifting and scaling the lines.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the rectification nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.SpikingRectifiedLinear">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">SpikingRectifiedLinear</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified integrate and fire neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless the current is less than zero, at
which point the neural activity will stay at zero. This is a spiking
version of the RectifiedLinear neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.SpikingRectifiedLinear.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Use RectifiedLinear to determine rates.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.SpikingRectifiedLinear.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">spiked</em>, <em class="sig-param">voltage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the integrate and fire nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Sigmoid">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Sigmoid</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_ref=0.0025</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>A neuron model whose response curve is a sigmoid.</p>
<p>Since the tuning curves are strictly positive, the <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>
correspond to the inflection point of each sigmoid. That is,
<code class="docutils literal notranslate"><span class="pre">f(intercept)</span> <span class="pre">=</span> <span class="pre">0.5</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> is the pure sigmoid function.</p>
<dl class="method">
<dt id="nengo.Sigmoid.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rates</em>, <em class="sig-param">intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the sigmoid nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.LIF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LIF</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_rc=0.02</em>, <em class="sig-param">tau_ref=0.002</em>, <em class="sig-param">min_voltage=0</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>min_voltage</strong><span class="classifier">float</span></dt><dd><p>Minimum value for the membrane voltage. If <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.LIF.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">spiked</em>, <em class="sig-param">voltage</em>, <em class="sig-param">refractory_time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIF.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.LIFRate">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LIFRate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_rc=0.02</em>, <em class="sig-param">tau_ref=0.002</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.LIFRate.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rates</em>, <em class="sig-param">intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always use LIFRate to determine rates.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">AdaptiveLIF</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_n=1</em>, <em class="sig-param">inc_n=0.01</em>, <em class="sig-param">tau_rc=0.02</em>, <em class="sig-param">tau_ref=0.002</em>, <em class="sig-param">min_voltage=0</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal notranslate"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is incremented by <code class="docutils literal notranslate"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>min_voltage</strong><span class="classifier">float</span></dt><dd><p>Minimum value for the membrane voltage. If <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r77178e5e5e1c-1"><span class="brackets">R77178e5e5e1c-1</span></dt>
<dd><p>Camera, Giancarlo La, et al. “Minimal models of adapted neuronal
response to in Vivo-Like input currents.” Neural computation
16.10 (2004): 2101-2124.</p>
</dd>
</dl>
<dl class="method">
<dt id="nengo.AdaptiveLIF.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em>, <em class="sig-param">voltage</em>, <em class="sig-param">ref</em>, <em class="sig-param">adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIF nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIFRate">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">AdaptiveLIFRate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_n=1</em>, <em class="sig-param">inc_n=0.01</em>, <em class="sig-param">tau_rc=0.02</em>, <em class="sig-param">tau_ref=0.002</em>, <em class="sig-param">amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive non-spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal notranslate"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is incremented by <code class="docutils literal notranslate"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2c73dd51a65a-1"><span class="brackets">R2c73dd51a65a-1</span></dt>
<dd><p>Camera, Giancarlo La, et al. “Minimal models of adapted neuronal
response to in Vivo-Like input currents.” Neural computation
16.10 (2004): 2101-2124.</p>
</dd>
</dl>
<dl class="method">
<dt id="nengo.AdaptiveLIFRate.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">output</em>, <em class="sig-param">adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Izhikevich">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Izhikevich</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau_recovery=0.02</em>, <em class="sig-param">coupling=0.2</em>, <em class="sig-param">reset_voltage=-65.0</em>, <em class="sig-param">reset_recovery=8.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich" title="Permalink to this definition">¶</a></dt>
<dd><p>Izhikevich neuron model.</p>
<p>This implementation is based on the original paper <a class="reference internal" href="#re23bd9a90d80-1" id="id4"><span>[Re23bd9a90d80-1]</span></a>;
however, we rename some variables for clarity.
What was originally ‘v’ we term ‘voltage’, which represents the membrane
potential of each neuron. What was originally ‘u’ we term ‘recovery’,
which represents membrane recovery, “which accounts for the activation
of K+ ionic currents and inactivation of Na+ ionic currents.”
The ‘a’, ‘b’, ‘c’, and ‘d’ parameters are also renamed
(see the parameters below).</p>
<p>We use default values that correspond to regular spiking (‘RS’) neurons.
For other classes of neurons, set the parameters as follows.</p>
<ul class="simple">
<li><p>Intrinsically bursting (IB): <code class="docutils literal notranslate"><span class="pre">reset_voltage=-55,</span> <span class="pre">reset_recovery=4</span></code></p></li>
<li><p>Chattering (CH): <code class="docutils literal notranslate"><span class="pre">reset_voltage=-50,</span> <span class="pre">reset_recovery=2</span></code></p></li>
<li><p>Fast spiking (FS): <code class="docutils literal notranslate"><span class="pre">tau_recovery=0.1</span></code></p></li>
<li><p>Low-threshold spiking (LTS): <code class="docutils literal notranslate"><span class="pre">coupling=0.25</span></code></p></li>
<li><p>Resonator (RZ): <code class="docutils literal notranslate"><span class="pre">tau_recovery=0.1,</span> <span class="pre">coupling=0.26</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_recovery</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘a’) Time scale of the recovery variable.</p>
</dd>
<dt><strong>coupling</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘b’) How sensitive recovery is to subthreshold
fluctuations of voltage.</p>
</dd>
<dt><strong>reset_voltage</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘c’) The voltage to reset to after a spike, in millivolts.</p>
</dd>
<dt><strong>reset_recovery</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘d’) The recovery value to reset to after a spike.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re23bd9a90d80-1"><span class="brackets"><a class="fn-backref" href="#id4">Re23bd9a90d80-1</a></span></dt>
<dd><p>E. M. Izhikevich, “Simple model of spiking neurons.”
IEEE Transactions on Neural Networks, vol. 14, no. 6, pp. 1569-1572.
(<a class="reference external" href="http://www.izhikevich.org/publications/spikes.pdf">http://www.izhikevich.org/publications/spikes.pdf</a>)</p>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Izhikevich.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">gain</em>, <em class="sig-param">bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates steady-state firing rate given gain and bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Izhikevich.step_math">
<code class="sig-name descname">step_math</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">J</em>, <em class="sig-param">spiked</em>, <em class="sig-param">voltage</em>, <em class="sig-param">recovery</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the Izhikevich nonlinearity.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="learning-rule-types">
<h2>Learning rule types<a class="headerlink" href="#learning-rule-types" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.learning_rules.LearningRuleType" title="nengo.learning_rules.LearningRuleType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.learning_rules.LearningRuleType</span></code></a></p></td>
<td><p>Base class for all learning rule objects.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.PES</span></code></a></p></td>
<td><p>Prescribed Error Sensitivity learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.BCM" title="nengo.BCM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.BCM</span></code></a></p></td>
<td><p>Bienenstock-Cooper-Munroe learning rule.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Oja" title="nengo.Oja"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Oja</span></code></a></p></td>
<td><p>Oja learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Voja" title="nengo.Voja"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Voja</span></code></a></p></td>
<td><p>Vector Oja learning rule.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.learning_rules.LearningRuleType">
<em class="property">class </em><code class="sig-prename descclassname">nengo.learning_rules.</code><code class="sig-name descname">LearningRuleType</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">learning_rate=Default&lt;1e-06&gt;</em>, <em class="sig-param">size_in=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#LearningRuleType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all learning rule objects.</p>
<p>To use a learning rule, pass it as a <code class="docutils literal notranslate"><span class="pre">learning_rule_type</span></code> keyword
argument to the <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> on which you want to do learning.</p>
<p>Each learning rule exposes two important pieces of metadata that the
builder uses to determine what information should be stored.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">size_in</span></code> is the dimensionality of the incoming error signal. It
can either take an integer or one of the following string values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'pre'</span></code>: vector error signal in pre-object space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'post'</span></code>: vector error signal in post-object space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'mid'</span></code>: vector error signal in the <code class="docutils literal notranslate"><span class="pre">conn.size_mid</span></code> space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'pre_state'</span></code>: vector error signal in pre-synaptic ensemble space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'post_state'</span></code>: vector error signal in pre-synaptic ensemble space</p></li>
</ul>
<p>The difference between <code class="docutils literal notranslate"><span class="pre">'post_state'</span></code> and <code class="docutils literal notranslate"><span class="pre">'post'</span></code> is that with the
former, if a <code class="docutils literal notranslate"><span class="pre">Neurons</span></code> object is passed, it will use the dimensionality
of the corresponding <code class="docutils literal notranslate"><span class="pre">Ensemble</span></code>, whereas the latter simply uses the
<code class="docutils literal notranslate"><span class="pre">post</span></code> object <code class="docutils literal notranslate"><span class="pre">size_in</span></code>. Similarly with <code class="docutils literal notranslate"><span class="pre">'pre_state'</span></code> and <code class="docutils literal notranslate"><span class="pre">'pre'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">modifies</span></code> attribute denotes the signal targeted by the rule.
Options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'encoders'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'decoders'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'weights'</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which <code class="docutils literal notranslate"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, str, optional</span></dt><dd><p>Dimensionality of the error signal (see above).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which <code class="docutils literal notranslate"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, str</span></dt><dd><p>Dimensionality of the error signal.</p>
</dd>
<dt><strong>modifies</strong><span class="classifier">str</span></dt><dd><p>The signal targeted by the learning rule.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.PES">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">PES</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">learning_rate=Default&lt;0.0001&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">pre_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#PES"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PES" title="Permalink to this definition">¶</a></dt>
<dd><p>Prescribed Error Sensitivity learning rule.</p>
<p>Modifies a connection’s decoders to minimize an error signal provided
through a connection to the connection’s learning rule.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.BCM">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">BCM</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">learning_rate=Default&lt;1e-09&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">post_synapse=Default&lt;None&gt;</em>, <em class="sig-param">theta_synapse=Default&lt;Lowpass(tau=1.0)&gt;</em>, <em class="sig-param">pre_tau=Unconfigurable</em>, <em class="sig-param">post_tau=Unconfigurable</em>, <em class="sig-param">theta_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#BCM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.BCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bienenstock-Cooper-Munroe learning rule.</p>
<p>Modifies connection weights as a function of the presynaptic activity
and the difference between the postsynaptic activity and the average
postsynaptic activity.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal notranslate"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal notranslate"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>theta_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The BCM rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the BCM rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the BCM rule by <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>theta_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.Oja">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Oja</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">learning_rate=Default&lt;1e-06&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">post_synapse=Default&lt;None&gt;</em>, <em class="sig-param">beta=Default&lt;1.0&gt;</em>, <em class="sig-param">pre_tau=Unconfigurable</em>, <em class="sig-param">post_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Oja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Oja" title="Permalink to this definition">¶</a></dt>
<dd><p>Oja learning rule.</p>
<p>Modifies connection weights according to the Hebbian Oja rule, which
augments typically Hebbian coactivity with a “forgetting” term that is
proportional to the weight of the connection and the square of the
postsynaptic activity.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal notranslate"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal notranslate"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar weight on the forgetting term.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Oja rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the Oja rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the Oja rule by <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>beta</strong><span class="classifier">float</span></dt><dd><p>A scalar weight on the forgetting term.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.Voja">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Voja</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">learning_rate=Default&lt;0.01&gt;</em>, <em class="sig-param">post_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">post_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Voja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Voja" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector Oja learning rule.</p>
<p>Modifies an ensemble’s encoders to be selective to its inputs.</p>
<p>A connection to the learning rule will provide a scalar weight for the
learning rate, minus 1. For instance, 0 is normal learning, -1 is no
learning, and less than -1 causes anti-learning or “forgetting”.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>post_tau</strong><span class="classifier">float, optional</span></dt><dd><p>Filter constant on activities of neurons in post population.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="processes">
<h2>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Process</span></code></a></p></td>
<td><p>A general system with input, output, and state.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.PresentInput" title="nengo.processes.PresentInput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.PresentInput</span></code></a></p></td>
<td><p>Present a series of inputs, each for the same fixed length of time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.FilteredNoise" title="nengo.processes.FilteredNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.FilteredNoise</span></code></a></p></td>
<td><p>Filtered white noise process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.BrownNoise" title="nengo.processes.BrownNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.BrownNoise</span></code></a></p></td>
<td><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.WhiteNoise" title="nengo.processes.WhiteNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.WhiteNoise</span></code></a></p></td>
<td><p>Full-spectrum white noise process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.WhiteSignal" title="nengo.processes.WhiteSignal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.WhiteSignal</span></code></a></p></td>
<td><p>An ideal low-pass filtered white noise process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.Piecewise" title="nengo.processes.Piecewise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.Piecewise</span></code></a></p></td>
<td><p>A piecewise function with different options for interpolation.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Process">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Process</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">default_size_in=0</em>, <em class="sig-param">default_size_out=1</em>, <em class="sig-param">default_dt=0.001</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>A general system with input, output, and state.</p>
<p>For more details on how to use processes and make
custom process subclasses, see <a class="reference internal" href="examples/advanced/processes.html"><span class="doc">Processes and how to use them</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>Sets the default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>Sets the default size out for nodes running this process. Also,
if <code class="docutils literal notranslate"><span class="pre">d</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>The default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The default size out for nodes running this process. Also, if <code class="docutils literal notranslate"><span class="pre">d</span></code> is
not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int or None</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.Process.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">d=None</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em class="sig-param">copy=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process on a given input.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>The input signal given to the process.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, a new output array will be created for output.
If False, the input signal <code class="docutils literal notranslate"><span class="pre">x</span></code> will be overwritten.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.get_rng">
<code class="sig-name descname">get_rng</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.get_rng"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.get_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a properly seeded independent RNG for the process step.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>The parent random number generator to use if the seed is not set.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">t</em>, <em class="sig-param">d=None</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given length of time.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The length of time to run.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run_steps">
<code class="sig-name descname">run_steps</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">d=None</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given number of steps.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_steps</strong><span class="classifier">int</span></dt><dd><p>The number of steps to run.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.ntrange">
<code class="sig-name descname">ntrange</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_steps</em>, <em class="sig-param">dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.ntrange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.ntrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given number of steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_steps</strong><span class="classifier">int</span></dt><dd><p>The given number of steps.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.trange">
<code class="sig-name descname">trange</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">t</em>, <em class="sig-param">dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.trange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.trange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given length of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The given length of time.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.PresentInput">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">PresentInput</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">inputs</em>, <em class="sig-param">presentation_time</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#PresentInput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput" title="Permalink to this definition">¶</a></dt>
<dd><p>Present a series of inputs, each for the same fixed length of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inputs</strong><span class="classifier">array_like</span></dt><dd><p>Inputs to present, where each row is an input. Rows will be flattened.</p>
</dd>
<dt><strong>presentation_time</strong><span class="classifier">float</span></dt><dd><p>Show each input for this amount of time (in seconds).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.processes.PresentInput.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#PresentInput.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.FilteredNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">FilteredNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">synapse=Lowpass(tau=0.005)</em>, <em class="sig-param">dist=Gaussian(mean=0</em>, <em class="sig-param">std=1)</em>, <em class="sig-param">scale=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#FilteredNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Filtered white noise process.</p>
<p>This process takes white noise and filters it using the provided synapse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>synapse</strong><span class="classifier">Synapse, optional</span></dt><dd><p>The synapse to use to filter the noise.</p>
</dd>
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution used to generate the white noise.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to scale the white noise for integration, making the output
signal invariant to <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.processes.FilteredNoise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#FilteredNoise.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.BrownNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">BrownNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dist=Gaussian(mean=0</em>, <em class="sig-param">std=1)</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#BrownNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.BrownNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p>
<p>This process is the integral of white noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution used to generate the white noise.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">WhiteNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dist=Gaussian(mean=0</em>, <em class="sig-param">std=1)</em>, <em class="sig-param">scale=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Full-spectrum white noise process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution from which to draw samples.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to scale the white noise for integration. Integrating white
noise requires using a time constant of <code class="docutils literal notranslate"><span class="pre">sqrt(dt)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">dt</span></code>
on the noise term <a class="reference internal" href="#rd2dd8a36bd47-1" id="id6"><span>[Rd2dd8a36bd47-1]</span></a>, to ensure the magnitude of the integrated
noise does not change with <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd2dd8a36bd47-1"><span class="brackets"><a class="fn-backref" href="#id6">Rd2dd8a36bd47-1</a></span></dt>
<dd><p>Gillespie, D.T. (1996) Exact numerical simulation of the Ornstein-
Uhlenbeck process and its integral. Phys. Rev. E 54, pp. 2084-91.</p>
</dd>
</dl>
<dl class="method">
<dt id="nengo.processes.WhiteNoise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteNoise.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteSignal">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">WhiteSignal</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">period</em>, <em class="sig-param">high</em>, <em class="sig-param">rms=0.5</em>, <em class="sig-param">y0=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteSignal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>An ideal low-pass filtered white noise process.</p>
<p>This signal is created in the frequency domain, and designed to have
exactly equal power at all frequencies below the cut-off frequency,
and no power above the cut-off.</p>
<p>The signal is naturally periodic, so it can be used beyond its period
while still being continuous with continuous derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>period</strong><span class="classifier">float</span></dt><dd><p>A white noise signal with this period will be generated.
Samples will repeat after this duration.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float</span></dt><dd><p>The cut-off frequency of the low-pass filter, in Hz.
Must not exceed the Nyquist frequency for the simulation
timestep, which is <code class="docutils literal notranslate"><span class="pre">0.5</span> <span class="pre">/</span> <span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>rms</strong><span class="classifier">float, optional</span></dt><dd><p>The root mean square power of the filtered signal</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float, optional</span></dt><dd><p>Align the phase of each output dimension to begin at the value
that is closest (in absolute value) to y0.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.processes.WhiteSignal.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteSignal.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.Piecewise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">Piecewise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">data</em>, <em class="sig-param">interpolation='zero'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#Piecewise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>A piecewise function with different options for interpolation.</p>
<p>Given an input dictionary of <code class="docutils literal notranslate"><span class="pre">{0:</span> <span class="pre">0,</span> <span class="pre">0.5:</span> <span class="pre">-1,</span> <span class="pre">0.75:</span> <span class="pre">0.5,</span> <span class="pre">1:</span> <span class="pre">0}</span></code>,
this process  will emit the numerical values (0, -1, 0.5, 0)
starting at the corresponding time points (0, 0.5, 0.75, 1).</p>
<p>The keys in the input dictionary must be times (float or int).
The values in the dictionary can be floats, lists of floats,
or numpy arrays. All lists or numpy arrays must be of the same length,
as the output shape of the process will be determined by the shape
of the values.</p>
<p>Interpolation on the data points using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.3.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a> is also
supported. The default interpolation is ‘zero’, which creates a
piecewise function whose values change at the specified time points.
So the above example would be shortcut for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.75</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For times before the first specified time, an array of zeros (of
the correct length) will be emitted.
This means that the above can be simplified to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary mapping times to the values that should be emitted
at those times. Times must be numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values begin at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.3.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nengo.processes</span> <span class="k">import</span> <span class="n">Piecewise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">process</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">u</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">size_out</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">default_size_out</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">up</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">up</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="go">array([[ 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.58</span><span class="p">]</span>
<span class="go">array([[ 1.]])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary mapping times to the values that should be emitted
at those times. Times are numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str</span></dt><dd><p>One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values change at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.3.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.processes.Piecewise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#Piecewise.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="synapse-models">
<h2>Synapse models<a class="headerlink" href="#synapse-models" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.Synapse</span></code></a></p></td>
<td><p>Abstract base class for synapse models.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.synapses.filt" title="nengo.synapses.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.filt</span></code></a></p></td>
<td><p>Filter <code class="docutils literal notranslate"><span class="pre">signal</span></code> with <code class="docutils literal notranslate"><span class="pre">synapse</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.synapses.filtfilt" title="nengo.synapses.filtfilt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.filtfilt</span></code></a></p></td>
<td><p>Zero-phase filtering of <code class="docutils literal notranslate"><span class="pre">signal</span></code> using the <code class="docutils literal notranslate"><span class="pre">synapse</span></code> filter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.LinearFilter" title="nengo.LinearFilter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LinearFilter</span></code></a></p></td>
<td><p>General linear time-invariant (LTI) system synapse.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Lowpass" title="nengo.Lowpass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Lowpass</span></code></a></p></td>
<td><p>Standard first-order lowpass filter synapse.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Alpha" title="nengo.Alpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Alpha</span></code></a></p></td>
<td><p>Alpha-function filter synapse.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.synapses.Triangle" title="nengo.synapses.Triangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.Triangle</span></code></a></p></td>
<td><p>Triangular finite impulse response (FIR) synapse.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.synapses.Synapse">
<em class="property">class </em><code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">Synapse</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">default_size_in=1</em>, <em class="sig-param">default_size_out=None</em>, <em class="sig-param">default_dt=0.001</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for synapse models.</p>
<p>Conceptually, a synapse model emulates a biological synapse, taking in
input in the form of released neurotransmitter and opening ion channels
to allow more or less current to flow into the neuron.</p>
<p>In Nengo, the implementation of a synapse is as a specific case of a
<a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> in which the input and output shapes are the same.
The input is the current across the synapse, and the output is the current
that will be induced in the postsynaptic neuron.</p>
<p>Synapses also contain the <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filt</span></code></a> and <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filtfilt</span></code></a> methods,
which make it easy to use Nengo’s synapse models outside of Nengo
simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default_size_in</strong><span class="classifier">int, optional</span></dt><dd><p>The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The size_out used if not specified.
If None, will be the same as default_size_in.</p>
</dd>
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep used if not specified.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep used if not specified.</p>
</dd>
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The size_out used if not specified.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.synapses.Synapse.filt">
<code class="sig-name descname">filt</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">dt=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">y0=0</em>, <em class="sig-param">copy=True</em>, <em class="sig-param">filtfilt=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal notranslate"><span class="pre">x</span></code> with this synapse model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The signal to filter.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>The timestep of the input signal.
If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis along which to filter.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like, optional</span></dt><dd><p>The starting state of the filter output. Must be zero for
unstable linear systems.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to copy the input data, or simply work in-place.</p>
</dd>
<dt><strong>filtfilt</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, runs the process forward then backward on the signal,
for zero-phase filtering (like Matlab’s <code class="docutils literal notranslate"><span class="pre">filtfilt</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.filtfilt">
<code class="sig-name descname">filtfilt</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">x</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal notranslate"><span class="pre">x</span></code> using this filter.</p>
<p>Equivalent to <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filt(x,</span> <span class="pre">filtfilt=True,</span> <span class="pre">**kwargs)</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em>, <em class="sig-param">y0=0</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the synapse forward one time step.</p>
<p>At a minimum, Synapse subclasses must implement this method.
That implementation should return a callable that will perform
the synaptic filtering operation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>Shape of the input signal to be filtered.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>Shape of the output filtered signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The timestep of the simulation.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like, optional</span></dt><dd><p>The starting state of the filter output. If zero, each dimension
of the state will start at zero.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>Type of data used by the synapse model. This is important for
ensuring that certain synapses avoid or force integer division.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filt">
<code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">filt</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">synapse</em>, <em class="sig-param">dt</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal notranslate"><span class="pre">signal</span></code> with <code class="docutils literal notranslate"><span class="pre">synapse</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filtfilt">
<code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">filtfilt</code><span class="sig-paren">(</span><em class="sig-param">signal</em>, <em class="sig-param">synapse</em>, <em class="sig-param">dt</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal notranslate"><span class="pre">signal</span></code> using the <code class="docutils literal notranslate"><span class="pre">synapse</span></code> filter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filtfilt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LinearFilter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">num</em>, <em class="sig-param">den</em>, <em class="sig-param">analog=True</em>, <em class="sig-param">method='zoh'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>General linear time-invariant (LTI) system synapse.</p>
<p>This class can be used to implement any linear filter, given the
filter’s transfer function. <a class="reference internal" href="#r853643b3d554-1" id="id8"><span>[R853643b3d554-1]</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num</strong><span class="classifier">array_like</span></dt><dd><p>Numerator coefficients of transfer function.</p>
</dd>
<dt><strong>den</strong><span class="classifier">array_like</span></dt><dd><p>Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>analog</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r853643b3d554-1"><span class="brackets"><a class="fn-backref" href="#id8">R853643b3d554-1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Filter_%28signal_processing%29">https://en.wikipedia.org/wiki/Filter_%28signal_processing%29</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>analog</strong><span class="classifier">boolean</span></dt><dd><p>Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>den</strong><span class="classifier">ndarray</span></dt><dd><p>Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>num</strong><span class="classifier">ndarray</span></dt><dd><p>Numerator coefficients of transfer function.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string</span></dt><dd><p>The method to use for discretization (if <code class="docutils literal notranslate"><span class="pre">analog</span></code> is True). See
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cont2discrete.html#scipy.signal.cont2discrete" title="(in SciPy v1.3.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.cont2discrete</span></code></a> for information about the options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.LinearFilter.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine in series with another LinearFilter.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">frequencies</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transfer function at the given frequencies.</p>
<p class="rubric">Examples</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> function to make a Bode plot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">synapse</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">LinearFilter</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">synapse</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;magnitude [dB]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;phase [radians]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em>, <em class="sig-param">y0=0</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Step</span></code></a> instance that implements the linear filter.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.Step">
<em class="property">class </em><code class="sig-name descname">Step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">C</em>, <em class="sig-param">D</em>, <em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.Step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for LTI filtering step functions.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.NoX">
<em class="property">class </em><code class="sig-name descname">NoX</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">C</em>, <em class="sig-param">D</em>, <em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.NoX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.NoX" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for system with no state, only passthrough matrix (D).</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.OneX">
<em class="property">class </em><code class="sig-name descname">OneX</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">C</em>, <em class="sig-param">D</em>, <em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.OneX"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.OneX" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for systems with one state element and no passthrough (D).</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.NoD">
<em class="property">class </em><code class="sig-name descname">NoD</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">C</em>, <em class="sig-param">D</em>, <em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.NoD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.NoD" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for systems with no passthrough matrix (D).</p>
<dl class="simple">
<dt>Implements</dt><dd><p>x[t] = A x[t-1] + B u[t]
y[t] = C x[t]</p>
</dd>
</dl>
<p>Note how the input has been advanced one step as compared with the
General system below, to remove the unnecessary delay.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.General">
<em class="property">class </em><code class="sig-name descname">General</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">C</em>, <em class="sig-param">D</em>, <em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.General"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.General" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for any LTI system with at least one state element (X).</p>
<dl class="simple">
<dt>Implements</dt><dd><p>x[t+1] = A x[t] + B u[t]
y[t] = C x[t] + D u[t]</p>
</dd>
</dl>
<p>Use <code class="docutils literal notranslate"><span class="pre">NoX</span></code> for systems with no state elements.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Lowpass">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Lowpass</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Lowpass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard first-order lowpass filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.Alpha">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Alpha</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tau</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha-function filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<p>and was found by <a class="reference internal" href="#r2fca3e9f2935-1" id="id10">[1]</a> to be a good basic model for synapses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2fca3e9f2935-1"><span class="brackets"><a class="fn-backref" href="#id10">1</a></span></dt>
<dd><p>Mainen, Z.F. and Sejnowski, T.J. (1995). Reliability of spike timing
in neocortical neurons. Science (New York, NY), 268(5216):1503-6.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.synapses.Triangle">
<em class="property">class </em><code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">Triangle</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">t</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular finite impulse response (FIR) synapse.</p>
<p>This synapse has a triangular and finite impulse response. The length of
the triangle is <code class="docutils literal notranslate"><span class="pre">t</span></code> seconds; thus the digital filter will have
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">/</span> <span class="pre">dt</span> <span class="pre">+</span> <span class="pre">1</span></code> taps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Length of the triangle, in seconds.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Length of the triangle, in seconds.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nengo.synapses.Triangle.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">shape_in</em>, <em class="sig-param">shape_out</em>, <em class="sig-param">dt</em>, <em class="sig-param">rng</em>, <em class="sig-param">y0=0</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a custom step function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="decoder-and-connection-weight-solvers">
<h2>Decoder and connection weight solvers<a class="headerlink" href="#decoder-and-connection-weight-solvers" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Solver</span></code></a></p></td>
<td><p>Decoder or weight solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Lstsq</span></code></a></p></td>
<td><p>Unregularized least-squares solver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqNoise" title="nengo.solvers.LstsqNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqNoise</span></code></a></p></td>
<td><p>Least-squares solver with additive Gaussian white noise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqMultNoise" title="nengo.solvers.LstsqMultNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqMultNoise</span></code></a></p></td>
<td><p>Least-squares solver with multiplicative white noise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2</span></code></a></p></td>
<td><p>Least-squares solver with L2 regularization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2nz</span></code></a></p></td>
<td><p>Least-squares solver with L2 regularization on non-zero components.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL1" title="nengo.solvers.LstsqL1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL1</span></code></a></p></td>
<td><p>Least-squares solver with L1 and L2 regularization (elastic net).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqDrop" title="nengo.solvers.LstsqDrop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqDrop</span></code></a></p></td>
<td><p>Find sparser decoders/weights by dropping small values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.Nnls" title="nengo.solvers.Nnls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Nnls</span></code></a></p></td>
<td><p>Non-negative least-squares solver without regularization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.NnlsL2" title="nengo.solvers.NnlsL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NnlsL2</span></code></a></p></td>
<td><p>Non-negative least-squares solver with L2 regularization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.NnlsL2nz" title="nengo.solvers.NnlsL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NnlsL2nz</span></code></a></p></td>
<td><p>Non-negative least-squares with L2 regularization on nonzero components.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.NoSolver" title="nengo.solvers.NoSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NoSolver</span></code></a></p></td>
<td><p>Manually pass in weights, bypassing the decoder solver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.LeastSquaresSolver</span></code></a></p></td>
<td><p>Linear least squares system solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.Cholesky" title="nengo.utils.least_squares_solvers.Cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.Cholesky</span></code></a></p></td>
<td><p>Solve a least-squares system using the Cholesky decomposition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.ConjgradScipy" title="nengo.utils.least_squares_solvers.ConjgradScipy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.ConjgradScipy</span></code></a></p></td>
<td><p>Solve a least-squares system using Scipy’s conjugate gradient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.LSMRScipy" title="nengo.utils.least_squares_solvers.LSMRScipy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.LSMRScipy</span></code></a></p></td>
<td><p>Solve a least-squares system using Scipy’s LSMR.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.Conjgrad" title="nengo.utils.least_squares_solvers.Conjgrad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.Conjgrad</span></code></a></p></td>
<td><p>Solve a least-squares system using conjugate gradient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.BlockConjgrad" title="nengo.utils.least_squares_solvers.BlockConjgrad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.BlockConjgrad</span></code></a></p></td>
<td><p>Solve a multiple-RHS least-squares system using block conj.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.SVD" title="nengo.utils.least_squares_solvers.SVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.SVD</span></code></a></p></td>
<td><p>Solve a least-squares system using full SVD.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.RandomizedSVD" title="nengo.utils.least_squares_solvers.RandomizedSVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.RandomizedSVD</span></code></a></p></td>
<td><p>Solve a least-squares system using a randomized (partial) SVD.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.solvers.Solver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Solver</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Decoder or weight solver.</p>
<p>A solver can be compositional or non-compositional. Non-compositional
solvers must operate on the whole neuron-to-neuron weight matrix, while
compositional solvers operate in the decoded state space, which is then
combined with transform/encoders to generate the full weight matrix.
See the solver’s <code class="docutils literal notranslate"><span class="pre">compositional</span></code> class attribute to determine if it is
compositional.</p>
<dl class="method">
<dt id="nengo.solvers.Solver.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">A</em>, <em class="sig-param">Y</em>, <em class="sig-param">rng=&lt;module 'numpy.random' from '/home/travis/virtualenv/python3.6.3/lib/python3.6/site-packages/numpy/random/__init__.py'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the solver.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>A</strong><span class="classifier">(n_eval_points, n_neurons) array_like</span></dt><dd><p>Matrix of the neurons’ activities at the evaluation points</p>
</dd>
<dt><strong>Y</strong><span class="classifier">(n_eval_points, dimensions) array_like</span></dt><dd><p>Matrix of the target decoded values for each of the D dimensions,
at each of the evaluation points.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>A random number generator to use as required.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>X</strong><span class="classifier">(n_neurons, dimensions) or (n_neurons, post.n_neurons) ndarray</span></dt><dd><p>(n_neurons, dimensions) array of decoders (if <code class="docutils literal notranslate"><span class="pre">solver.weights</span></code>
is False) or (n_neurons, post.n_neurons) array of weights
(if <code class="docutils literal notranslate"><span class="pre">'solver.weights</span></code> is True).</p>
</dd>
<dt><strong>info</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of information about the solver. All dictionaries have
an <code class="docutils literal notranslate"><span class="pre">'rmses'</span></code> key that contains RMS errors of the solve.
Other keys are unique to particular solvers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Lstsq">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Lstsq</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">rcond=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Lstsq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregularized least-squares solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>rcond</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rcond</strong><span class="classifier">float</span></dt><dd><p>Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.16)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">noise=0.1</em>, <em class="sig-param">solver=Cholesky()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with additive Gaussian white noise.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>noise</strong><span class="classifier">float</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqMultNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqMultNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">noise=0.1</em>, <em class="sig-param">solver=Cholesky()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqMultNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqMultNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with multiplicative white noise.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>noise</strong><span class="classifier">float</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL2</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">reg=0.1</em>, <em class="sig-param">solver=Cholesky()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2nz">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL2nz</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">reg=0.1</em>, <em class="sig-param">solver=Cholesky()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization on non-zero components.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL1">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL1</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">l1=0.0001</em>, <em class="sig-param">l2=1e-06</em>, <em class="sig-param">max_iter=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L1 and L2 regularization (elastic net).</p>
<p>This method is well suited for creating sparse decoders or weight matrices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <a class="reference external" href="https://scikit-learn.org/stable/">scikit-learn</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>l1</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of L2 regularization.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>l1</strong><span class="classifier">float</span></dt><dd><p>Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float</span></dt><dd><p>Amount of L2 regularization.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqDrop">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqDrop</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">drop=0.25</em>, <em class="sig-param">solver1=LstsqL2(reg=0.001)</em>, <em class="sig-param">solver2=LstsqL2()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqDrop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Find sparser decoders/weights by dropping small values.</p>
<p>This solver first solves for coefficients (decoders/weights) with
L2 regularization, drops those nearest to zero, and retrains remaining.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>drop</strong><span class="classifier">float, optional</span></dt><dd><p>Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong><span class="classifier">Solver, optional</span></dt><dd><p>Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong><span class="classifier">Solver, optional</span></dt><dd><p>Used for re-solving for the decoders after dropout.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>drop</strong><span class="classifier">float</span></dt><dd><p>Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong><span class="classifier">Solver</span></dt><dd><p>Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong><span class="classifier">Solver</span></dt><dd><p>Used for re-solving for the decoders after dropout.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Nnls">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Nnls</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Nnls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver without regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lstsq</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NnlsL2</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver with L2 regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LstsqL2</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2nz">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NnlsL2nz</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights=False</em>, <em class="sig-param">reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares with L2 regularization on nonzero components.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LstsqL2nz</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NoSolver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NoSolver</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">values=None</em>, <em class="sig-param">weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NoSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NoSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually pass in weights, bypassing the decoder solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(n_neurons, size_out) array_like, optional</span></dt><dd><p>The array of decoders to use.
<code class="docutils literal notranslate"><span class="pre">size_out</span></code> is the dimensionality of the decoded signal (determined
by the connection function).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, connection will use factored weights (decoders from this
solver, transform, and encoders).
If True, connection will use a full weight matrix (created by
linearly combining decoder, transform, and encoders).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(n_neurons, size_out) array_like, optional</span></dt><dd><p>The array of decoders to use.
<code class="docutils literal notranslate"><span class="pre">size_out</span></code> is the dimensionality of the decoded signal (determined
by the connection function).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, connection will use factored weights (decoders from this
solver, transform, and encoders).
If True, connection will use a full weight matrix (created by
linearly combining decoder, transform, and encoders).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.LeastSquaresSolver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">LeastSquaresSolver</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#LeastSquaresSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear least squares system solver.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.Cholesky">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">Cholesky</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">transpose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#Cholesky"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.Cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using the Cholesky decomposition.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.ConjgradScipy">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">ConjgradScipy</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tol=0.0001</em>, <em class="sig-param">atol=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#ConjgradScipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.ConjgradScipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using Scipy’s conjugate gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Relative tolerance of the CG solver (see <a class="reference internal" href="#r97899ec83cde-1" id="id14">[1]</a> for details).</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance of the CG solver (see <a class="reference internal" href="#r97899ec83cde-1" id="id15">[1]</a> for details).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r97899ec83cde-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id15">2</a>)</span></dt>
<dd><p>scipy.sparse.linalg.cg documentation,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.LSMRScipy">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">LSMRScipy</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tol=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#LSMRScipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.LSMRScipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using Scipy’s LSMR.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.Conjgrad">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">Conjgrad</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tol=0.01</em>, <em class="sig-param">maxiters=None</em>, <em class="sig-param">X0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#Conjgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.Conjgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using conjugate gradient.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.BlockConjgrad">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">BlockConjgrad</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tol=0.01</em>, <em class="sig-param">X0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#BlockConjgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.BlockConjgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a multiple-RHS least-squares system using block conj. gradient.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.SVD">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">SVD</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#SVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using full SVD.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.utils.least_squares_solvers.RandomizedSVD">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">RandomizedSVD</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n_components=60</em>, <em class="sig-param">n_oversamples=10</em>, <em class="sig-param">n_iter=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/utils/least_squares_solvers.html#RandomizedSVD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.RandomizedSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using a randomized (partial) SVD.</p>
<p>Useful for solving large matrices quickly, but non-optimally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_components</strong><span class="classifier">int, optional</span></dt><dd><p>The number of SVD components to compute. A small survey of activity
matrices suggests that the first 60 components capture almost all
the variance.</p>
</dd>
<dt><strong>n_oversamples</strong><span class="classifier">int, optional</span></dt><dd><p>The number of additional samples on the range of A.</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>The number of power iterations to perform (can help with noisy data).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-learn.org/dev/modules/generated/sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd" title="(in scikit-learn v0.22.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.utils.extmath.randomized_svd</span></code></a></dt><dd><p>Function used by this class</p>
</dd>
</dl>
</div>
</dd></dl>

</div>
</div>


        </div>
      </div>
    </div>
  </div>
</div><footer class="footer">
  <div class="w-container">
    <div class="w-clearfix">
      <div class="w-row search">
<form id="form-search" class="form-search" action="search.html" method="get">
  <div class="form-group">
    <input type="text" name="q" class="form-control" placeholder="Search" />
  </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form></div>
      <div class="w-row mobileAlign">
        <div class="w-col w-col-2 footer-menu">
          <p class="menu-Label">ABR, Inc.</p>
          <ul class="vertical-menu">
            <li class="footer-listitem-new"><a href="https://appliedbrainresearch.com/products/">Products</a></li>
            <li class="footer-listitem-new "><a href="https://appliedbrainresearch.com/services/">Services</a></li>
            <li class="footer-listitem-new"><a href="https://appliedbrainresearch.com/research/">Research</a></li>
          </ul>
        </div>
        <div class="w-col w-col-2 footer-menu">
          <p class="menu-Label">About Us</p>
          <ul class="vertical-menu">
            <li class="footer-listitem-new"><a href="https://appliedbrainresearch.com/about-us/">Contact</a></li>
            <li class="footer-listitem-new"><a href="https://appliedbrainresearch.com/about-us/#team">Team</a></li>
            <li class="footer-listitem-new"><a href="https://appliedbrainresearch.com/about-us/#culture">Culture</a></li>
          </ul>
        </div>
        <a class="brand footer-brand" href="https://appliedbrainresearch.com">
          <img src="https://appliedbrainresearch.com/img/logo-light-notext.svg" width="80">
        </a>
      </div>
    </div>
  </div>
</footer>
  </body>
</html>